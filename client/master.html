<!DOCTYPE html>
<html>
  <head>
    <meta name="screen-orientation" content="portrait" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0"
    />
    <title>å¹´ä¼šæŠ½å¥–å°ç¨‹åº</title>
    <link rel="stylesheet" type="text/css" href="css/reset.css" />
    <link rel="stylesheet" type="text/css" href="css/luckydraw.css" />
  </head>
  <body>
    <div id="app" class="wall" v-cloak>
      <!-- æ ‡ç­¾äº‘ -->
      <canvas :id="canvasId" :class="{mask: showResult}" :width="width" :height="height">
        <ul id="tags">
          <li v-for="item in member" :key="item.phone">
            <a href="javascript:void(0)" :style="{color: winners.includes(getKey(item)) ? 'yellow' : 'white'}">
              {{item.name}}
            </a>
          </li>
        </ul>
      </canvas>
      <!-- åœ¨çº¿äººæ•° -->
      <div id="connections" v-if="syncPush">
        <span>åœ¨çº¿äººæ•°ï¼š{{connections}}</span>
      </div>
      <!-- è·å¥–åå• -->
      <div id="result-btn">
        <span @click="showWinnerList = true">è·å¥–åå•</span>
      </div>
      <!-- æŠ½å¥–ç»“æœ -->
      <div id="result" v-show="showResult">
        <span v-for="item in currentWinner" :key="item.phone"> {{item.name}}<br />{{item.phone}} </span>
      </div>
      <!-- è·å¥–åå•åˆ—è¡¨ -->
      <div id="list" v-show="showWinnerList" @click="showWinnerList = false">
        <div class="result-title">{{winnerList ? "è·å¥–åå•" : "æš‚æ— æŠ½å¥–è®°å½•"}}</div>
        <template v-if="winnerList">
          <div class="result-list" v-for="key in Object.keys(winnerList).reverse()" :key="key">
            <div class="prize-name">{{key}}</div>
            <div v-for="item in winnerList[key]" :key="item.phone">
              <span>{{item.name}} {{item.phone}}</span>
            </div>
          </div>
        </template>
      </div>
      <!-- æ“ä½œæ  -->
      <div id="tools">
        <button
          v-for="item in prize"
          :key="item.name"
          class="pure-button"
          :class="{ 'button-error': currentPrize?.name === item.name}"
          :disabled="running"
          @click="handleChoosePrize(item)"
        >
          {{item.name}}({{item.quota}})
        </button>
        <button
          class="pure-button"
          :class="{'button-secondary': !running, 'button-success': running}"
          @click="handleToggle"
        >
          {{running?"åœ!":"å¼€å§‹"}}
        </button>
        <button class="pure-button button-warning" :disabled="running" @click="handelReset">é‡ç½®</button>
      </div>
    </div>
    <script type="text/javascript" src="js/vue.min.js"></script>
    <!-- https://www.goat1000.com/tagcanvas-options.php -->
    <script type="text/javascript" src="js/tagcanvas.min.js"></script>
    <script type="text/javascript" src="js/confetti.browser.min.js"></script>
    <script type="text/javascript" src="js/server.js"></script>
    <script type="text/javascript">
      const app = new Vue({
        el: "#app",
        data() {
          return {
            member: [],
            prize: [],
            currentPrize: null,
            showResult: false,
            currentWinner: [],
            winnerList: null,
            showWinnerList: false,
            running: false,
            syncPush: server.enabled,
            socket: null,
            socketName: "ws://" + server.ip + ":" + server.port,
            connections: 0,
            canvasId: "ball",
            speed: [0.04, -0.06], // å·¦å³ ä¸Šä¸‹
            width: document.body.offsetWidth,
            height: document.body.offsetHeight,
          };
        },
        computed: {
          winners() {
            const list = [];
            if (this.winnerList) {
              Object.keys(this.winnerList).forEach((prizeName) => {
                this.winnerList[prizeName].forEach((memberItem) => {
                  list.push(this.getKey(memberItem));
                });
              });
            }
            return list;
          },
        },
        watch: {
          showResult(newVal, oldVal) {
            if (newVal) {
              setTimeout(() => {
                this.fireworks();
              }, 0);
            }
          },
          winnerList(newVal, oldVal) {
            // console.log("ğŸš€ ~ winnerList:", newVal, oldVal);
            // ä¿å­˜åå•(è·¨é¡µé¢ä¼ è¾“ç”¨)
            localStorage.setItem("winnerList", JSON.stringify(newVal));
            // é‡è½½æ ‡ç­¾äº‘
            this.$nextTick(() => {
              TagCanvas.Reload(this.canvasId);
            });
          },
        },
        created() {
          this.syncPush
            ? this.createSocket()
            : this.loadScript("js/config.js", () => {
                const winnerListStr = localStorage.getItem("winnerList");
                this.init({
                  member: member.length > 0 ? member : this.member,
                  prize: prize.length > 0 ? prize : this.prize,
                  currentPrize: prize.length > 0 ? prize[0] : this.currentPrize,
                  showResult: this.showResult,
                  currentWinner: this.currentWinner,
                  winnerList: winnerListStr !== null ? JSON.parse(winnerListStr) : this.winnerList,
                  running: this.running,
                });
              });
        },
        mounted() {},
        methods: {
          createSocket() {
            // åˆ›å»ºWebSocketå®ä¾‹ï¼Œè¿æ¥åˆ°æŒ‡å®šçš„æœåŠ¡å™¨åœ°å€
            const socket = new WebSocket(this.socketName);
            this.socket = socket;
            // å½“è¿æ¥æˆåŠŸæ‰“å¼€æ—¶è§¦å‘çš„äº‹ä»¶
            socket.onopen = (event) => {
              console.log("WebSocketè¿æ¥å·²æ‰“å¼€");
              // è¿™é‡Œå¯ä»¥è¿›è¡Œä¸€äº›åˆå§‹åŒ–æ“ä½œï¼Œæ¯”å¦‚å‘æœåŠ¡å™¨å‘é€è¿æ¥æˆåŠŸåçš„æ ‡è¯†ç­‰
              this.send("tag", "master");
              // å¿ƒè·³
              setInterval(() => {
                this.send("ping");
              }, 50000);
            };
            // å½“æ¥æ”¶åˆ°æœåŠ¡å™¨å‘é€çš„æ¶ˆæ¯æ—¶è§¦å‘çš„äº‹ä»¶
            socket.onmessage = (event) => {
              const message = JSON.parse(event.data);
              console.log("WebSocketæ”¶åˆ°æ¶ˆæ¯", message.emit);
              switch (message.emit) {
                case "init":
                  this.init(message.data);
                  break;
                case "connections":
                  this.connections = message.data;
                  break;
              }
            };
            // å½“è¿æ¥å‡ºç°é”™è¯¯æ—¶è§¦å‘çš„äº‹ä»¶
            socket.onerror = (error) => {
              console.log("WebSocketè¿æ¥å‡ºé”™:", error);
              alert("WebSocketè¿æ¥å‡ºé”™");
            };
            // å½“è¿æ¥å…³é—­æ—¶è§¦å‘çš„äº‹ä»¶
            socket.onclose = (event) => {
              console.log("WebSocketè¿æ¥å·²å…³é—­");
              if (confirm("è¿æ¥å·²æ–­å¼€ï¼Œæ˜¯å¦é‡è¿ï¼Ÿ")) {
                location.reload();
              }
            };
          },
          loadScript(url, success, error) {
            const script = document.createElement("script");
            script.src = url;
            script.onload = () => {
              typeof success === "function" && success();
            };
            script.onerror = (event) => {
              console.error("æ— æ³•åŠ è½½è„šæœ¬æ–‡ä»¶ï¼š" + event.target.src);
              typeof success === "function" && error(event);
            };
            document.body.appendChild(script);
          },
          send(emit, data = null) {
            console.log("ğŸš€ ~ send:", { emit, data });
            this.syncPush && this.socket.send(JSON.stringify({ emit, data }));
          },
          /* ç”¨æˆ·å”¯ä¸€æ ‡è¯† */
          getKey(item) {
            return item.name + "-" + item.phone;
          },
          // åˆå§‹åŒ–
          init({ member, prize, currentPrize, showResult, currentWinner, winnerList, running }) {
            this.member = member;
            this.prize = prize;
            this.currentPrize = currentPrize;
            this.showResult = showResult;
            this.currentWinner = currentWinner;
            this.winnerList = winnerList;
            this.running = running;
            // this.$nextTickä¸­çš„å›è°ƒå‡½æ•°å°±ä¼šåœ¨ DOM æ›´æ–°åæ‰§è¡Œ
            this.$nextTick(() => {
              TagCanvas.Start(this.canvasId, "tags", {
                textColour: null,
                textHeight: 14,
                initial: this.speed,
                dragControl: true,
              });
              // æ¢å¤çŠ¶æ€
              if (running === true) {
                TagCanvas.SetSpeed(
                  this.canvasId,
                  this.speed.map((item) => item * 100)
                );
              }
            });
            // æ¸…é™¤å†å²è®°å½•
            if (winnerList === null && localStorage.getItem("winnerList")) {
              localStorage.removeItem("winnerList");
            }
          },
          /* å¼€å§‹æŠ½å¥– */
          start() {
            if (this.prize.length === 0) {
              alert("å¥–å“åˆ—è¡¨ä¸ºç©º");
              return;
            }
            if (this.winners.length >= this.member.length) {
              alert("å¯ä¸­å¥–äººæ•°ä¸è¶³");
              return;
            }
            if (this.winnerList && this.winnerList[this.currentPrize.name]) {
              if (confirm("å½“å‰å¥–é¡¹å·²æœ‰ä¸­å¥–åå•ï¼Œæ˜¯å¦é‡æŠ½?")) {
                this.$delete(this.winnerList, this.currentPrize.name);
              } else {
                return;
              }
            }
            this.running = true;
            this.currentWinner = [];
            this.showResult = false;
            TagCanvas.SetSpeed(
              this.canvasId,
              this.speed.map((item) => item * 100)
            );
            this.send("start", {
              running: this.running,
              currentWinner: this.currentWinner,
              showResult: this.showResult,
            });
          },
          /* åœæ­¢æŠ½å¥– */
          stop() {
            const currentWinner = this.lottery(this.currentPrize.quota);
            this.running = false;
            this.currentWinner = currentWinner;
            this.showResult = true;
            if (this.winnerList === null) {
              this.winnerList = { [this.currentPrize.name]: currentWinner };
            } else {
              this.$set(this.winnerList, this.currentPrize.name, currentWinner);
            }
            TagCanvas.SetSpeed(this.canvasId, this.speed);
            this.send("stop", {
              running: this.running,
              currentWinner: this.currentWinner,
              showResult: this.showResult,
              winnerList: this.winnerList,
            });
          },
          /* æŠ½å¥– */
          lottery(count) {
            return this.member
              .filter((item) => {
                return !this.winners.includes(this.getKey(item));
              })
              .map((item) => {
                item.score = Math.random();
                return item;
              })
              .sort((a, b) => {
                return a.score - b.score;
              })
              .slice(0, count)
              .map((item) => {
                delete item.score;
                return item;
              });
          },
          /* æ˜¾ç¤ºçƒŸèŠ± */
          fireworks() {
            function fire(particleRatio, opts) {
              confetti({
                ...{
                  origin: { y: 0.7 },
                },
                ...opts,
                particleCount: Math.floor(200 * particleRatio),
              });
            }
            fire(0.25, {
              spread: 26,
              startVelocity: 55,
            });
            fire(0.2, {
              spread: 60,
            });
            fire(0.35, {
              spread: 100,
              decay: 0.91,
              scalar: 0.8,
            });
            fire(0.1, {
              spread: 120,
              startVelocity: 25,
              decay: 0.92,
              scalar: 1.2,
            });
            fire(0.1, {
              spread: 120,
              startVelocity: 45,
            });
          },
          // é€‰æ‹©å¥–é¡¹
          handleChoosePrize(prize) {
            if (this.running) return;
            this.currentPrize = prize;
            this.showResult = false;
            // å¤„ç†æ‹–æ‹½åæ»šåŠ¨åœæ­¢çš„é—®é¢˜
            TagCanvas.SetSpeed(this.canvasId, this.speed);
            this.send("choosePrize", {
              currentPrize: this.currentPrize,
              showResult: this.showResult,
            });
          },
          handleToggle() {
            this.running ? this.stop() : this.start();
          },
          handelReset() {
            if (this.running) return;
            if (confirm("ç¡®å®šè¦é‡ç½®ä¹ˆï¼Ÿæ‰€æœ‰ä¹‹å‰çš„æŠ½å¥–å†å²å°†è¢«æ¸…é™¤ï¼")) {
              this.send("reset");
              localStorage.clear();
              location.reload();
            }
          },
        },
      });
    </script>
  </body>
</html>
